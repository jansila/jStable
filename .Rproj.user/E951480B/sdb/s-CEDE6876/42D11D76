{
    "collab_server" : "",
    "contents" : "dyn.load(\"src/stable.so\")\n\n\n###########################################################################\n#' Density of a stable distribution\n#'\n#' This function produces the stable density computed at y.\n#' Note that it is obtained by integrating a function from 0 to Infinity.\n#' This integral is approximated by the finite integral from 0 to UP\n#' using the Simpson's method with npt points or Romberg's integration. Core of the code is based on Philipe Lambert's code https://github.com/cran/stable\n#'\n#'\n#' @param input series of input\n#' @param vec vector of class \"stableFit\" MLE estimates from mleFit\n#' @return vector of densities of input for given 4 parameters (alpha-tail, beta-skew, gamma-scale, delta-location)\n#' @examples denStable(rnorm(500), alpha=2,beta=0,gamma=1/sqrt(2), delta=0)\n#'\n\n\n#' @useDynLib stable stable\ndenStable <- function(input, vec=NULL, alpha=1.8, beta=0, gamma=1/sqrt(2), delta=0,\n                    npt=501, up=10, eps=1.0e-6, integration=\"Romberg\"){\n\n  if(!is.null(vec) && class(vec)==\"stableFit\" && !any(is.na(vec$estimate)) ){\n    alpha=c(vec$estimate[1])\n    beta=c(vec$estimate[2])\n    gamma=c(vec$estimate[3])\n    delta=c(vec$estimate[4])\n    }else{alpha=alpha;beta=beta;gamma=gamma;delta=delta}\n\n#special cases\n#  if (alpha == 2 && beta==0) {\n  #  return(stats::dnorm(y, mean = 0, sd = 1))\n # } else{ if (alpha == 1 && beta == 0) {\n#return(stats::dcauchy(y, log=log))}}\n\n  type <- ifelse(integration==\"Simpson\",1,2)\n\n  ly <- length(input)\n  z0 <- rep(0,ly)\n  skew <- beta+z0\n  tail <- alpha+z0\n  yy <- (input-delta)/gamma\n  z <- .C(\"stable\",\n\t  as.integer(ly),\n\t  yy,\n\t  skew,\n\t  tail,\n\t  as.integer(npt),\n\t  up,\n\t  eps,\n\t  as.integer(type),\n\t  err=integer(1),\n\t  ffy=double(ly))\n\n  z$ffy/gamma\n  }\n\n\n###########################################################################\n\n#' Function computes\n\n\n#' @useDynLib stable stable\nprobStable <- function(y, loc=0,disp=1/sqrt(2),skew=0,tail=2,eps=1.0e-6){\n  if (alpha == 2 && beta==0) {\n    return(pnorm(y, mean = 0, sd = 1, log=log))\n  } else if (alpha == 1 && beta == 0) {\n    return(pcauchy(y, log=log))}\n\n\n\n  yy <- (y-loc)/disp\n  ly <- length(yy)\n  z0 <- rep(0,ly)\n  skew <- skew+z0\n  tail <- tail+z0\n  eta <- skew*(1-abs(1-tail))*pi/2\n#        if ((yy==0)&(eta==0)) return(0.5+z0)\n  z <- .C(\"pstable\",\n\t  as.integer(ly),\n\t  yy,\n\t  skew,\n\t  tail,\n\t  eps,\n\t  err=integer(1),\n\t  ffy=double(ly))\n  z$ffy}\n\n###########################################################################\n# Quantile function of a stable random variable\n#\n\nquantStable <- function(p, alpha=2,beta=0,gamma=1/sqrt(2),delta=0){\n if(alpha==2){return(qnorm(p))}\n\n  if(alpha==1 && beta){return(qcauchy(p))}\n\n  stabledist::qstable(p, alpha=alpha,beta=beta,gamma=gamma,delta=delta)\n  }\n\n###########################################################################\n# Generation of stable random deviates\n#\nrandStable <- function(n=1,delta=0,gamma=1/sqrt(2),beta=0,alpha=2){\n return(quantStable(runif(n),delta=delta,gamma=gamma,beta=beta,alpha=alpha))}\n",
    "created" : 1470934333912.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4205236062",
    "id" : "42D11D76",
    "lastKnownWriteTime" : 1471257736,
    "last_content_update" : 1471257736448,
    "path" : "~/Desktop/Dissertation/myPack/myStable/R/stable.r",
    "project_path" : "R/stable.r",
    "properties" : {
        "docOutlineVisible" : "1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}